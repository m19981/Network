"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendInteractionResponse = void 0;
const shared_js_1 = require("../../types/shared.js");
/**
 * Send a response to a users application command. The command data will have the id and token necessary to respond.
 * Interaction `tokens` are valid for **15 minutes** and can be used to send followup messages.
 *
 * NOTE: By default we will suppress mentions. To enable mentions, just pass any mentions object.
 */
async function sendInteractionResponse(bot, id, token, options) {
    // If no mentions are provided, force disable mentions
    if (!options.data?.allowedMentions) {
        options.data = { ...options.data, allowedMentions: { parse: [] } };
    }
    // DRY code a little bit
    const data = {
        content: options.data.content,
        tts: options.data.tts,
        embeds: options.data.embeds?.map((embed) => bot.transformers.reverse.embed(bot, embed)),
        allowed_mentions: {
            parse: options.data.allowedMentions.parse,
            replied_user: options.data.allowedMentions.repliedUser,
            users: options.data.allowedMentions.users?.map((id) => id.toString()),
            roles: options.data.allowedMentions.roles?.map((id) => id.toString()),
        },
        file: options.data.file,
        custom_id: options.data.customId,
        title: options.data.title,
        components: options.data.components?.map((component) => ({
            type: component.type,
            components: component.components.map((subComponent) => {
                if (subComponent.type === shared_js_1.MessageComponentTypes.InputText) {
                    return {
                        type: subComponent.type,
                        style: subComponent.style,
                        custom_id: subComponent.customId,
                        label: subComponent.label,
                        placeholder: subComponent.placeholder,
                        min_length: subComponent.minLength ?? subComponent.required === false ? 0 : subComponent.minLength,
                        max_length: subComponent.maxLength,
                    };
                }
                if (subComponent.type === shared_js_1.MessageComponentTypes.SelectMenu) {
                    return {
                        type: subComponent.type,
                        custom_id: subComponent.customId,
                        placeholder: subComponent.placeholder,
                        min_values: subComponent.minValues,
                        max_values: subComponent.maxValues,
                        options: subComponent.options.map((option) => ({
                            label: option.label,
                            value: option.value,
                            description: option.description,
                            emoji: option.emoji
                                ? {
                                    id: option.emoji.id?.toString(),
                                    name: option.emoji.name,
                                    animated: option.emoji.animated,
                                }
                                : undefined,
                            default: option.default,
                        })),
                    };
                }
                return {
                    type: subComponent.type,
                    custom_id: subComponent.customId,
                    label: subComponent.label,
                    style: subComponent.style,
                    emoji: "emoji" in subComponent && subComponent.emoji
                        ? {
                            id: subComponent.emoji.id?.toString(),
                            name: subComponent.emoji.name,
                            animated: subComponent.emoji.animated,
                        }
                        : undefined,
                    url: "url" in subComponent ? subComponent.url : undefined,
                    disabled: "disabled" in subComponent ? subComponent.disabled : undefined,
                };
            }),
        })),
        flags: options.data.flags,
        choices: options.data.choices,
    };
    // A reply has never been send
    if (bot.cache.unrepliedInteractions.delete(id)) {
        return await bot.rest.runMethod(bot.rest, "post", bot.constants.endpoints.INTERACTION_ID_TOKEN(id, token), {
            type: options.type,
            data,
        });
    }
    // If its already been executed, we need to send a followup response
    const result = await bot.rest.runMethod(bot.rest, "post", bot.constants.endpoints.WEBHOOK(bot.applicationId, token), data);
    return bot.transformers.message(bot, result);
}
exports.sendInteractionResponse = sendInteractionResponse;
