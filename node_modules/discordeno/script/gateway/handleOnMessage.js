"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleOnMessage = void 0;
const dntShim = __importStar(require("../_dnt.shims.js"));
const bigint_js_1 = require("../util/bigint.js");
const utils_js_1 = require("../util/utils.js");
const deps_js_1 = require("./deps.js");
const shared_js_1 = require("../types/shared.js");
/** Handler for handling every message event from websocket. */
// deno-lint-ignore no-explicit-any
async function handleOnMessage(gateway, message, shardId) {
    if (gateway.compress && message instanceof dntShim.Blob) {
        message = (0, deps_js_1.decompressWith)(new Uint8Array(await message.arrayBuffer()), 0, (slice) => gateway.utf8decoder.decode(slice));
    }
    if (typeof message !== "string")
        return;
    const shard = gateway.shards.get(shardId);
    const messageData = JSON.parse(message);
    gateway.debug("GW RAW", { shardId, payload: messageData });
    switch (messageData.op) {
        case shared_js_1.GatewayOpcodes.Heartbeat:
            if (shard?.ws.readyState !== dntShim.WebSocket.OPEN)
                return;
            shard.heartbeat.lastSentAt = Date.now();
            // Discord randomly sends this requiring an immediate heartbeat back
            gateway.sendShardMessage(gateway, shard, {
                op: shared_js_1.GatewayOpcodes.Heartbeat,
                d: shard?.previousSequenceNumber,
            }, true);
            break;
        case shared_js_1.GatewayOpcodes.Hello:
            gateway.heartbeat(gateway, shardId, messageData.d.heartbeat_interval);
            // UPDATES THE SAFE AMOUNT OF SHARDS BASED ON THE INTERVAL
            if (shard)
                shard.safeRequestsPerShard = gateway.safeRequestsPerShard(gateway, shard);
            break;
        case shared_js_1.GatewayOpcodes.HeartbeatACK:
            if (gateway.shards.has(shardId)) {
                const shard = gateway.shards.get(shardId);
                shard.heartbeat.acknowledged = true;
                shard.heartbeat.lastReceivedAt = Date.now();
            }
            break;
        case shared_js_1.GatewayOpcodes.Reconnect:
            gateway.debug("GW RECONNECT", { shardId });
            if (gateway.shards.has(shardId)) {
                gateway.shards.get(shardId).resuming = true;
            }
            gateway.resume(gateway, shardId);
            break;
        case shared_js_1.GatewayOpcodes.InvalidSession:
            gateway.debug("GW INVALID_SESSION", { shardId, payload: messageData });
            // We need to wait for a random amount of time between 1 and 5: https://discord.com/developers/docs/topics/gateway#resuming
            await (0, utils_js_1.delay)(Math.floor((Math.random() * 4 + 1) * 1000));
            // When d is false we need to re-identify
            if (!messageData.d) {
                await gateway.identify(gateway, shardId, gateway.maxShards);
                break;
            }
            if (gateway.shards.has(shardId)) {
                gateway.shards.get(shardId).resuming = true;
            }
            gateway.resume(gateway, shardId);
            break;
        default:
            if (messageData.t === "RESUMED") {
                gateway.debug("GW RESUMED", { shardId });
                if (gateway.shards.has(shardId)) {
                    gateway.shards.get(shardId).resuming = false;
                }
                break;
            }
            // Important for RESUME
            if (messageData.t === "READY") {
                // Wait few seconds to spawn next shard
                const bucket = gateway.buckets.get(shardId % gateway.maxConcurrency);
                if (bucket?.createNextShard.length) {
                    // await delay(gateway.spawnShardDelay);
                    // setTimeout(() => {
                    console.log("shifting to create new shard");
                    bucket.createNextShard.shift()?.();
                    // }, gateway.spawnShardDelay);
                }
                const shard = gateway.shards.get(shardId);
                const payload = messageData.d;
                if (shard) {
                    shard.sessionId = payload.session_id;
                    shard.ready = true;
                }
                payload.guilds.forEach((g) => gateway.cache.loadingGuildIds.add((0, bigint_js_1.snowflakeToBigint)(g.id)));
                gateway.loadingShards.get(shardId)?.resolve(true);
                gateway.loadingShards.delete(shardId);
            }
            // Update the sequence number if it is present
            if (messageData.s) {
                const shard = gateway.shards.get(shardId);
                if (shard) {
                    shard.previousSequenceNumber = messageData.s;
                }
            }
            // MUST HANDLE GUILD_CREATE EVENTS AS THEY ARE EXPENSIVE WITHOUT GATEWAY CACHE
            if (messageData.t === "GUILD_CREATE") {
                const id = (0, bigint_js_1.snowflakeToBigint)(messageData.d.id);
                // SHARD RESUMED MOST LIKELY, THEY EMIT GUILD CREATES. OR GUILD BECAME AVAILABLE AGAIN
                if (gateway.cache.guildIds.has(id))
                    return;
                // GUILD WAS MARKED LOADING IN READY EVENT, THIS WAS THE FIRST GUILD_CREATE TO ARRIVE
                if (gateway.cache.loadingGuildIds.has(id)) {
                    messageData.t = "GUILD_LOADED_DD";
                    gateway.cache.loadingGuildIds.delete(id);
                }
                gateway.cache.guildIds.add(id);
            }
            // MESSAGE_UPDATE CAN SPAM FOR NO REASON USE THIS TO IGNORE
            if (messageData.t === "MESSAGE_UPDATE") {
                const payload = messageData.d;
                const id = (0, bigint_js_1.snowflakeToBigint)(payload.id);
                const content = payload.content || "";
                const cached = gateway.cache.editedMessages.get(id);
                if (cached === content)
                    return;
                else {
                    // ADD TO LOCAL CACHE FOR FUTURE EVENTS.
                    gateway.cache.editedMessages.set(id, content);
                    // REMOVE AFTER 10 SECONDS FROM CACHE
                    dntShim.setTimeout(() => {
                        gateway.cache.editedMessages.delete(id);
                    }, 10000);
                }
            }
            // MUST HANDLE GUILD_DELETE EVENTS FOR UNAVAILABLE
            if (messageData.t === "GUILD_DELETE") {
                if (messageData.d.unavailable)
                    return;
            }
            // IF NO TYPE THEN THIS SHOULD NOT BE SENT FORWARD
            if (!messageData.t)
                return;
            await gateway.handleDiscordPayload(gateway, messageData, shardId);
            break;
    }
}
exports.handleOnMessage = handleOnMessage;
