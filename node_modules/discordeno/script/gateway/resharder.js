"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reshardingEditGuildShardIds = exports.markNewGuildShardId = exports.startReshardingChecks = exports.resharderCloseOldShards = exports.resharderIsPending = exports.resharder = void 0;
const dntShim = __importStar(require("../_dnt.shims.js"));
const gatewayBot_js_1 = require("../transformers/gatewayBot.js");
const collection_js_1 = require("../util/collection.js");
const gatewayManager_js_1 = require("./gatewayManager.js");
/** The handler to automatically reshard when necessary. */
async function resharder(oldGateway, results) {
    oldGateway.debug("GW DEBUG", "[Resharding] Starting the reshard process.");
    const gateway = (0, gatewayManager_js_1.createGatewayManager)({
        ...oldGateway,
        // RESET THE SETS AND COLLECTIONS
        cache: {
            guildIds: new Set(),
            loadingGuildIds: new Set(),
            editedMessages: new collection_js_1.Collection(),
        },
        shards: new collection_js_1.Collection(),
        loadingShards: new collection_js_1.Collection(),
        buckets: new collection_js_1.Collection(),
        utf8decoder: new TextDecoder(),
    });
    for (const [key, value] of Object.entries(oldGateway)) {
        if (key === "handleDiscordPayload") {
            gateway.handleDiscordPayload = async function (_, data, shardId) {
                if (data.t === "READY") {
                    const payload = data.d;
                    await gateway.resharding.markNewGuildShardId(payload.guilds.map((g) => BigInt(g.id)), shardId);
                }
            };
            continue;
        }
        // USE ANY CUSTOMIZED OPTIONS FROM OLD GATEWAY
        // @ts-ignore TODO: fix this dynamical assignment
        gateway[key] = oldGateway[key];
    }
    // Begin resharding
    gateway.maxShards = results.shards;
    // FOR MANUAL SHARD CONTROL, OVERRIDE THIS SHARD ID!
    gateway.lastShardId = oldGateway.lastShardId === oldGateway.maxShards ? gateway.maxShards : oldGateway.lastShardId;
    gateway.shardsRecommended = results.shards;
    gateway.sessionStartLimitTotal = results.sessionStartLimit.total;
    gateway.sessionStartLimitRemaining = results.sessionStartLimit.remaining;
    gateway.sessionStartLimitResetAfter = results.sessionStartLimit.resetAfter;
    gateway.maxConcurrency = results.sessionStartLimit.maxConcurrency;
    // If more than 100K servers, begin switching to 16x sharding
    if (gateway.useOptimalLargeBotSharding) {
        gateway.debug("GW DEBUG", "[Resharding] Using optimal large bot sharding solution.");
        gateway.maxShards = gateway.calculateMaxShards(gateway.maxShards, results.sessionStartLimit.maxConcurrency);
    }
    gateway.spawnShards(gateway, gateway.firstShardId);
    return new Promise((resolve) => {
        // TIMER TO KEEP CHECKING WHEN ALL SHARDS HAVE RESHARDED
        const timer = dntShim.setInterval(async () => {
            const pending = await gateway.resharding.isPending(gateway, oldGateway);
            // STILL PENDING ON SOME SHARDS TO BE CREATED
            if (pending)
                return;
            // ENABLE EVENTS ON NEW SHARDS AND IGNORE EVENTS ON OLD
            const oldHandler = oldGateway.handleDiscordPayload;
            gateway.handleDiscordPayload = oldHandler;
            oldGateway.handleDiscordPayload = function (og, data, shardId) {
                // ALLOW EXCEPTION FOR CHUNKING TO PREVENT REQUESTS FREEZING
                if (data.t !== "GUILD_MEMBERS_CHUNK")
                    return;
                oldHandler(og, data, shardId);
            };
            // STOP TIMER
            clearInterval(timer);
            await gateway.resharding.editGuildShardIds();
            await gateway.resharding.closeOldShards(oldGateway);
            gateway.debug("GW DEBUG", "[Resharding] Complete.");
            resolve(gateway);
        }, 30000);
    });
}
exports.resharder = resharder;
/** Handler that by default will check all new shards are online in the new gateway. The handler can be overridden if you have multiple servers to communicate through redis pubsub or whatever you prefer. */
async function resharderIsPending(gateway, oldGateway) {
    for (let i = gateway.firstShardId; i < gateway.lastShardId; i++) {
        const shard = gateway.shards.get(i);
        if (!shard?.ready) {
            return true;
        }
    }
    return false;
}
exports.resharderIsPending = resharderIsPending;
/** Handler that by default closes all shards in the old gateway. Can be overridden if you have multiple servers and you want to communicate through redis pubsub or whatever you prefer. */
async function resharderCloseOldShards(oldGateway) {
    // SHUT DOWN ALL SHARDS IF NOTHING IN QUEUE
    oldGateway.shards.forEach((shard) => {
        // CLOSE THIS SHARD IT HAS NO QUEUE
        if (!shard.processingQueue && !shard.queue.length) {
            return oldGateway.closeWS(shard.ws, 3066, "Shard has been resharded. Closing shard since it has no queue.");
        }
        // IF QUEUE EXISTS GIVE IT 5 MINUTES TO COMPLETE
        dntShim.setTimeout(() => {
            oldGateway.closeWS(shard.ws, 3066, "Shard has been resharded. Delayed closing shard since it had a queue.");
        }, 300000);
    });
}
exports.resharderCloseOldShards = resharderCloseOldShards;
/** Handler that by default will check to see if resharding should occur. Can be overridden if you have multiple servers and you want to communicate through redis pubsub or whatever you prefer. */
async function startReshardingChecks(gateway) {
    gateway.debug("GW DEBUG", "[Resharding] Checking if resharding is needed.");
    // TODO: is it possible to route this to REST?
    const results = (await dntShim.fetch(`https://discord.com/api/gateway/bot`, {
        headers: {
            Authorization: `Bot ${gateway.token}`,
        },
    }).then((res) => res.json()).then((res) => (0, gatewayBot_js_1.transformGatewayBot)(res)));
    const percentage = ((results.shards - gateway.maxShards) / gateway.maxShards) * 100;
    // Less than necessary% being used so do nothing
    if (percentage < gateway.reshardPercentage)
        return;
    // Don't have enough identify rate limits to reshard
    if (results.sessionStartLimit.remaining < results.shards)
        return;
    // MULTI-SERVER BOTS OVERRIDE THIS IF YOU NEED TO RESHARD SERVER BY SERVER
    return gateway.resharding.resharder(gateway, results);
}
exports.startReshardingChecks = startReshardingChecks;
/** Handler that by default will save the new shard id for each guild this becomes ready in new gateway. This can be overridden to save the shard ids in a redis cache layer or whatever you prefer. These ids will be used later to update all guilds. */
async function markNewGuildShardId(guildIds, shardId) {
    // PLACEHOLDER TO LET YOU MARK A GUILD ID AND SHARD ID FOR LATER USE ONCE RESHARDED
}
exports.markNewGuildShardId = markNewGuildShardId;
/** Handler that by default does not do anything since by default the library will not cache. */
async function reshardingEditGuildShardIds() {
    // PLACEHOLDER TO LET YOU UPDATE CACHED GUILDS
}
exports.reshardingEditGuildShardIds = reshardingEditGuildShardIds;
